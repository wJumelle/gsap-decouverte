<!DOCTYPE html>
<html lang="fr">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Getting started</title>
    </head>
    <body class="page page--category-1">
        <header>
            <nav>
                <a href="../../index.html">Retour √† l'accueil</a>
            </nav>
            <h1>Getting started</h1>
            <nav>
                <ul>
                    <li><a href="#section_1">D√©composition d'un appel GSAP</a></li>
                    <li><a href="#section_2">D√©couverte des diff√©rentes m√©thodes</a></li>
                    <li><a href="#section_3">Les targets</a></li>
                    <li><a href="#section_4">Les variables</a></li>
                    <li><a href="#section_5">Easing</a></li>
                </ul>
            </nav>
        </header>
        <main>
            <p>Il est l'heure de commencer √† apprendre ! ü§ì</p>
            <section id="section_1">
                <h2>D√©composition d'un appel GSAP</h2>
                <code>
                    gsap.to(".square", { x: 600 })
                </code>
                <p>
                    Ici on demande √† <strong>gsap</strong> de faire appel √† la <strong>m√©thode</strong> to(),
                    de cibler la <strong>target</strong> ".square", donc notre √©l√©ment HTML poss√©dant la classe "square",
                    et d'y appliquer les transformations fournies en <strong>variables</strong>, ici {x: 600}.
                </p>
                <span>
                    Il existe 4 m√©thodes diff√©rentes :
                </span>
                <ul class="list">
                    <li>gsap.to()</li>
                    <li>gsap.from()</li>
                    <li>gsap.fromTo()</li>
                    <li>gsap.set()</li>
                </ul>
            </section>
            <hr>
            <section id="section_2">
                <h2>D√©couverte des diff√©rentes m√©thodes</h2>
                <h3>1 - gsap.to()</h3>
                <p>
                    Elle correspond √† notre premi√®re m√©thode. C'est basiquement la plus utilis√©e car elle
                    repr√©sente la fonctionnalit√© la plus attendue : on part d'un √©tat A (l'origine) et
                    on anime jusqu'√† un √©tat B.
                    L'origine correspond au positionnement initial de l'√©l√©ment HTML tel qu'il est positionn√©
                    dans le DOM √† l'aide du CSS.
                </p>
                <code>
                    const tween_1 = gsap.to(".animation--1 .square", { x: 600 });<br/>
                    document.getElementById('anim_1_button').addEventListener('click', () => {<br/>
                    &nbsp;&nbsp;&nbsp;&nbsp;tween_1.restart();<br/>
                    });
                </code>
                <div class="preview animation-container animation--1">
                    <div class="square-ghost square-ghost--a">A</div>
                    <div class="square">Square</div>
                    <div class="square-ghost square-ghost--b">B</div>
                    <button id="anim_1_button" class="button">Jouer l'animation</button>
                </div>
                <p>
                    On a ainsi cr√©√© un <strong>tween</strong>, c'est √† dire une animation.
                    C'est souvent ce nom que va porter la constante lorsque l'on va nommer notre √©l√©ment pour
                    g√©rer son d√©clenchement.<br/>
                </p>
                <h3>2 - gsap.from()</h3>
                <p>
                    C'est l'inverse de la m√©thode to(), on a l'√©tat initial de notre carr√© qui
                    est toujours le m√™me, soit la position par d√©faut d'un √©l√©ment positionn√© relativement,
                    en haut √† gauche.<br />
                    Ici, on indique donc une animation qui simule un nouvel √©tat d'origine (B) pour aller
                    vers notre √©tat initial (A).
                </p>
                <code>
                    const tween_2 = gsap.from(".animation--2 .square", { x: 600 });<br/>
                    document.getElementById('anim_2_button').addEventListener('click', () => {<br/>
                    &nbsp;&nbsp;&nbsp;&nbsp;tween_2.restart();<br/>
                    });
                </code>
                <div class="preview animation-container animation--2">
                    <div class="square-ghost square-ghost--a">A</div>
                    <div class="square">Square</div>
                    <div class="square-ghost square-ghost--b">B</div>
                    <button id="anim_2_button" class="button">Jouer l'animation</button>
                </div>
                <h3>3 - gsap.fromTo()</h3>
                <p>
                    Cette m√©thode est la fusion des deux premi√®res, on d√©finit √† la fois
                    la valeur de l'√©tat de d√©but/origine et la valeur de l'√©tat de fin.<br/>
                    Elle permet de g√©rer avec certitude les diff√©rents √©tats d'une animation.
                </p>
                <code>
                    const tween_3 = gsap.fromTo(".animation--3 .square", { x: 0 }, { x: 600 });<br/>
                    document.getElementById('anim_3_button').addEventListener('click', () => {<br/>
                    &nbsp;&nbsp;&nbsp;&nbsp;tween_3.restart();<br/>
                    });
                </code>
                <div class="preview animation-container animation--3">
                    <div class="square-ghost square-ghost--a">A</div>
                    <div class="square">Square</div>
                    <div class="square-ghost square-ghost--b">B</div>
                    <button id="anim_3_button" class="button">Jouer l'animation</button>
                </div>
                <h3>4 - gsap.set()</h3>
                <p>
                    Et enfin, la m√©thode set est tout simplement une m√©thode qui va sauter de l'√©tat
                    d'origine vers l'√©tat final de l'animation sans animer la chose.
                </p>
                <code>
                    const tween_4 = gsap.set(".animation--4 .square", { x: 600, paused: true });<br/>
                    document.getElementById('anim_4_button_play').addEventListener('click', () => {<br/>
                    &nbsp;&nbsp;&nbsp;&nbsp;tween_4.restart();<br/>
                    });<br/>
                    document.getElementById('anim_4_button_reset').addEventListener('click', () => {<br/>
                    &nbsp;&nbsp;&nbsp;&nbsp;tween_4.reverse();<br/>
                    });
                </code>
                <div class="preview animation-container animation--4">
                    <div class="square-ghost square-ghost--a">A</div>
                    <div class="square">Square</div>
                    <div class="square-ghost square-ghost--b">B</div>
                    <button id="anim_4_button_play" class="button">Jouer la non animation</button>
                    <button id="anim_4_button_reset" class="button">R√©initialiser la non animation</button>
                </div>
            </section>
            <hr>
            <section id="section_3">
                <h2>Les targets</h2>
                <p>
                    Ce que GSAP appelle les <strong>targets</strong> ce sont tout simplement
                    les cibles de notre animation.<br />
                    Ces cibles peuvent √™tre de diff√©rentes natures mais concr√®tement derri√®re ce premier
                    param√®tre de notre m√©thode se cache un simple appel √† <strong>document.querySelectorAll()</strong>.
                </p>
                <span>Voici les natures diff√©rentes que peuvent prendre les targets</span>
                <ul>
                    <li>un s√©lecteur CSS simple ou complexe</li>
                    <li>une variable</li>
                    <li>un tableau d'instance</li>
                </ul>
                <code>
                    // une classe ou un ID<br />
                    gsap.to(".box", { x: 200 });<br />
                    gsap.to("#myBox", { x: 200 });<br /><br />

                    // un s√©lecteur CSS complexe<br />
                    gsap.to("section > .box", { x: 200 });<br /><br />

                    // une variable<br />
                    let box = document.querySelector(".box");<br />
                    gsap.to(box, { x: 200 })<br /><br />

                    // un tableau d'√©l√©ments<br />
                    let square = document.querySelector(".square");<br />
                    let circle = document.querySelector(".circle");<br />
                    gsap.to([square, circle], { x: 200 })
                </code>
            </section>
            <hr>
            <section id="section_4">
                <h2>Les variables</h2>
                <h3>Les propri√©t√©s CSS</h3>
                <p>
                    L'objet de variable contient toutes les informations autour de notre animation.<br/>
                    Il peut s'agir de <strong>simple propri√©t√© CSS</strong> ou bien des
                    <strong>propri√©t√©s sp√©cifiques</strong> qui influencent sur le comportement de
                    l'animation (ex: <strong>duration</strong>, <strong>onComplete</strong>, <strong>repeat</strong>).
                </p>
                <p>
                    Il n'existe pas de liste exacte des propri√©t√©s qui peuvent anim√©es puisque toutes
                    les propri√©t√©es CSS en soit peuvent l'√™tre.<br />
                    GSAP de son cot√© n'attend qu'une seule chose, que la propri√©t√© soit √©crite en camelCase.
                </p>
                <p class="highlighted">
                    üí° Tips, et un peu üö® attention aussi..<br/>
                    Cependant, il est conseill√© de se tenir √† quelques propri√©t√©s CSS optimis√©es pour l'animation.<br />
                    Et dans ce cas de figure, il en existe surtout deux : <strong>transform</strong> et <strong>opacity</strong>.<br />
                    En effet, d'autres propri√©t√©s CSS s'av√®rent √™tre tr√®s gourmandes au niveau du CPU et cela
                    pourrait nuire √† l'exp√©rience de l'utilisateur ! (ex: <strong>filter</strong> et <strong>boxShadow</strong>)
                </p>
                <p>
                    C'est pour favoriser l'usage de ces deux propri√©t√©s d'ailleurs que GSAP a mis en
                    place des raccourcis pour les animer.<br />
                    Ainsi <strong>x</strong> que l'on animait jusque l√† est un raccourci pour <strong>transform: translateX(x)</strong>.
                </p>
                <code>
                    // Pour ce qui est de transform et opacity
                    x: 200, // transfrom: translateX(200px)<br />
                    y: 200, // transfrom: translateY(200px)<br />
                    xPercent: 50, // transfrom: translateX(50%)<br />
                    yPercent: 50, // transfrom: translateY(50%)<br />
                    scale: 2, // transfrom: scale(2)<br />
                    scaleX: 2, // transfrom: scaleX(2)<br />
                    scaleY: 2, // transfrom: scaleY(2)<br />
                    rotation: 90, // transfrom: rotation(90deg)<br />
                    rotation: "1.25rad", // r√©alise la transformation en radian, pas d'alternative CSS<br />
                    transformOrigin: "center 40%", // transform-origin: center 40%<br />
                    opacity: 0,<br />
                    autoAlpha: 0, // ajuste les props opacity et visiblity<br />
                    duration: 1, // animation-duration: 1s<br />
                    repeat: -1, // animation-iteration-count: infinite<br />
                    repeat: 2, // animation-iteration-count: 2<br />
                    delay: 2, // animation-delay: 2s<br />
                    yoyo: true, // animation-direction: alternate<br /><br />

                    // pour les autres propri√©t√©s en camelCase<br />
                    backgroundColor: 'red',
                </code>
                <h3>Les unit√©s</h3>
                <p>
                    Par d√©faut GSAP utilise les pixels (px) et les degr√©s (deg) pour les propri√©t√©s autour
                    de <strong>transform</strong>, mais il est tout √† fait possible d'en utiliser d'autres,
                    ou bien de lui transmettre un calcul via une fonction.
                </p>
                <code>
                    x: 200, // use default of px<br />
                    x: "+=200" // relative values<br />
                    x: '40vw', // or pass in a string with a different unit for GSAP to parse<br />
                    x: () => window.innerWidth / 2, // you can even use functional values to do a calculation!<br /><br />

                    rotation: 360 // use default of degrees<br />
                    rotation: "1.25rad" // use radians
                </code>
                <h3>Les attributs SVG</h3>
                <p>
                    Tout comme les propri√©t√©s CSS, les attributs de nos SVG sont animables ! ‚ú®<br/>
                    Cela veut donc dire qu'avec GSAP nous pouvons animer des attributs comme <strong>fill</strong>,
                    <strong>width</strong>, <strong>height</strong>, <strong>stroke</strong>, <strong>cx/rx</strong>,
                    <strong>opacity</strong> ou bien encore l'attribut <strong>viewBox</strong> directement !
                </p>
                <p>
                    Ci-dessous un code test, nous pouvons voir que nous r√©alisons les transformations
                    <strong>x: 100</strong> et <strong>xPercent: -100</strong>, pourquoi ?<br />
                    Tout comme en CSS, nous r√©alisons souvent ce petit trick, nous d√©pla√ßons l'objet
                    √† sa valeur maximal puis on soustrait la taille de l'objet afin qu'il se positionne
                    dans la limite de l'encadrement, sinon il sortirait du viewbox de notre svg !
                </p>
                <code>
                    // Animation 5 - SVG<br />
                    const tween_5 = gsap.to('.animation--5 .svgBox', {<br />
                    &nbsp;&nbsp;&nbsp;&nbsp;duration: 2,<br />
                    &nbsp;&nbsp;&nbsp;&nbsp;x: 100,<br />
                    &nbsp;&nbsp;&nbsp;&nbsp;xPercent: -100,<br />
                    &nbsp;&nbsp;&nbsp;&nbsp;paused: true,<br />
                    &nbsp;&nbsp;&nbsp;&nbsp;attr: {<br />
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fill: "#5235F4",<br />
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rx: 50<br />
                    &nbsp;&nbsp;&nbsp;&nbsp;}<br />
                    });<br />
                    document.getElementById('anim_5_button').addEventListener('click', () => {<br />
                    &nbsp;&nbsp;&nbsp;&nbsp;tween_5.restart();<br />
                    });
                </code>
                <div class="preview animation-container animation--5">
                    <svg id="svg" viewBox="0 0 100 100">
                        <rect fill="#F43578" class="svgBox" x="0" y="35" width="30" height="30" rx="2" />
                    </svg>
                    <button id="anim_5_button" class="button">Jouer l'animation</button>
                </div>
                <p class="highlighted">
                    üö® Attention<br />
                    Lors de mes tests j'ai voulu g√©rer l'attribut <strong>fill</strong> en CSS, pour
                    pouvoir y mettre mes variables, ce qui casse le fonctionnement de GSAP.<br />
                    En effet, comme j'avais supprim√© l'attribut de mon code HTML, GSAP n'√©tait plus en
                    mesure d' en animer sa valeur.
                </p>
                <p>
                    Voici, ci-dessous, une animation qui reprend un peu l'id√©e que l'on aimerait d√©velopper
                    pour l'expositon Machine arri√®re : radio.
                </p>
                <code>
                    // Animation 6 - SVG mouvement ghost<br />
                    const tween_6_1 = gsap.to('.animation--6 .svgBox--animated-1', {<br />
                    &nbsp;&nbsp;&nbsp;&nbsp;duration: 2,<br />
                    &nbsp;&nbsp;&nbsp;&nbsp;y: 35,<br />
                    &nbsp;&nbsp;&nbsp;&nbsp;paused: true,<br />
                    &nbsp;&nbsp;&nbsp;&nbsp;attr: {<br />
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fill: "#5235F4",<br />
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rx: 50<br />
                    &nbsp;&nbsp;&nbsp;&nbsp;}<br />
                    });<br />
                    const tween_6_2 = gsap.to('.animation--6 .svgBox--animated-1', {<br />
                    &nbsp;&nbsp;&nbsp;&nbsp;duration: 2,<br />
                    &nbsp;&nbsp;&nbsp;&nbsp;y: "-=35",<br />
                    &nbsp;&nbsp;&nbsp;&nbsp;paused: true,<br />
                    &nbsp;&nbsp;&nbsp;&nbsp;attr: {<br />
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fill: "#5235F4",<br />
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rx: 50<br />
                    &nbsp;&nbsp;&nbsp;&nbsp;}<br />
                    });<br />
                    document.getElementById('anim_6_button').addEventListener('click', () => {<br />
                    &nbsp;&nbsp;&nbsp;&nbsp;tween_6_1.restart();<br />
                    &nbsp;&nbsp;&nbsp;&nbsp;tween_6_2.restart();<br />
                    });
                </code>
                <div class="preview animation-container animation--6">
                    <svg id="svg" viewBox="0 0 100 100">
                        <rect fill="#F43578" class="svgBox svgBox--animated-1" x="0" y="0" width="30" height="30" rx="2" />
                        <rect fill="#F43578" class="svgBox" x="35" y="35" width="30" height="30" rx="2" />
                        <rect fill="#F43578" class="svgBox svgBox--animated-2" x="70" y="70" width="30" height="30" rx="2" />
                    </svg>
                    <button id="anim_6_button" class="button">Jouer l'animation</button>
                </div>
                <h3>En fait.. √ßa peut vraiment tout animer</h3>
                <p>
                    C'est un bon r√©sum√© ! Que √ßa soit une valeur num√©rique, une chaine de caract√®re simple ou
                    complexe (contenant des nombres), tous ces √©l√©ments peuvent √™tre anim√©s !<br />
                    <strong>On peut en effet animer tout ce que l'on veut √† l'int√©rieur de n'importe quel objet, et cet
                    objet n'a m√™me pas besoin d'√™tre un √©l√©ment du DOM !</strong><br /><br />
                    Ci-dessous, nous pouvons voir que nous sommes en capacit√© d'animer les propri√©t√©s
                    <strong>myNum</strong> et <strong>myColor</strong> et notre <strong>obj</strong>.
                </p>
                <code>
                    //create an object<br />
                    let obj = { myNum: 10, myColor: "red" };<br /><br />

                    gsap.to(obj, {<br />
                    &nbsp;&nbsp;&nbsp;&nbsp;myNum: 200,<br />
                    &nbsp;&nbsp;&nbsp;&nbsp;myColor: "blue",<br />
                    &nbsp;&nbsp;&nbsp;&nbsp;onUpdate: () => console.log(obj.myNum, obj.myColor)
                    });
                </code>
                <h3>Les canvas</h3>
                <p>
                    Et oui ! Ils ne font pas exception, il est tout √† fait possible d'animer
                    le rendu d'un canvas √† l'aide de GSAP, et cela de mani√®re totalement fluide.
                </p>
                <p>
                    Et √† quoi √ßa peut bien servir ? Et bah tout simplement √† animer des rendus
                    effectu√©s par les libraires comme Three.js, Pixi.js etc. Et √ßa... J'ACHETE ! üí∏
                </p>
                <code>
                    // Animation 7 - Canvas<br />
                    const canvas = document.getElementById("canvas");<br />
                    const ctx = canvas.getContext("2d");<br />
                    ctx.fillStyle = "#F43578";<br /><br />

                    // On va animer la position d'un carr√© dans notre canvas<br />
                    let position = { x: 0, y: 0 };<br /><br />

                    // On d√©clare la fonction qui va nous ppermettre de r√©initialiser le canvas √† chaque frame<br />
                    // et de redesinner le carr√© √† sa nouvelle position<br />
                    function draw() {<br />
                    &nbsp;&nbsp;&nbsp;&nbsp;ctx.clearRect(0, 0, 300, 300);<br />
                    &nbsp;&nbsp;&nbsp;&nbsp;ctx.fillRect(position.x, position.y, 100, 100);<br />
                    }<br /><br />

                    // On d√©clare l'animation<br />
                    // Contrairement √† un √©l√©ment du DOM un canvas a besoin d'√™tre redessin√© √† chaque frame<br />
                    // donc on est oblig√© de d√©clarer la propri√©t√© onUpdate<br />
                    // on d√©place jusqu'√† x: 200 et y: 200 car notre carr√© fait 100x100<br />
                    const tween_7 = gsap.to(position, {<br />
                    &nbsp;&nbsp;&nbsp;&nbsp;x: 200,<br />
                    &nbsp;&nbsp;&nbsp;&nbsp;y: 200,<br />
                    &nbsp;&nbsp;&nbsp;&nbsp;duration: 2,<br />
                    &nbsp;&nbsp;&nbsp;&nbsp;paused: true,<br />
                    &nbsp;&nbsp;&nbsp;&nbsp;onUpdate: draw<br />
                    });<br /><br />

                    document.getElementById('anim_7_button').addEventListener('click', () => {<br />
                    &nbsp;&nbsp;&nbsp;&nbsp;tween_7.restart();<br />
                    });
                </code>
                <div class="preview animation-container animation--7">
                    <canvas id="canvas" width="300" height="300"></canvas>
                    <button id="anim_7_button" class="button">Jouer l'animation</button>
                </div>
                <h3>Propri√©t√©s sp√©ciales</h3>
                <p>
                    Pour animer le comportement de nos √©l√©ments nous pouvons jouer avec diff√©rentes propri√©t√©es.<br />
                    En voici certaines ci-dessous, mais le reste est trouvable dans la
                    <a href="https://gsap.com/docs/v3/GSAP/Tween/#special-properties">documentation</a>.
                </p>
                <ul>
                    <li>
                        <strong>duration :</strong> √ßa permet tout simplement de d√©finir la dur√©e de l'animation.<br/>
                        <em>D√©faut: 0.5</em>
                    </li>
                    <li>
                        <strong>delay :</strong> c'est la dur√©e en seconde avant le d√©clenchement de l'animation.
                    </li>
                    <li>
                        <strong>repeat :</strong> c'est le nombre de fois o√π l'animation devra √™tre rejou√©.
                    </li>
                    <li>
                        <strong>yoyo :</strong> si cette propri√©t√© est d√©fini √† "true" au prochain tick de repeat l'animation se jouera dans le sens invers√©.<br/>
                        <em>D√©faut : false</em>
                    </li>
                    <li>
                        <strong>stagger :</strong> c'est le temps en seconde qui s√©pare chacune des animations. C'est utile lorsque la target contient plusieurs √©l√©ments.
                    </li>
                    <li>
                        <strong>ease :</strong> permet de controler le rythme de l'animation.<br/>
                        <em>D√©faut: power1.out</em>
                    </li>
                    <li>
                        <strong>onComplete :</strong> permet de d√©finir une fonction qui s'ex√©cute √† la fin de l'animation.
                    </li>
                </ul>
                <h3>"repeat" et "yoyo"</h3>
                <p>
                    "repeat" sert exactement √† ce √† quoi on pourrait s'attendre.<br/>
                    Il permet de r√©√©x√©cuter l'animation un certain nombre de fois, sachant que la valeur "-1" permet
                    de jouer l'animation √† l'infin.
                </p>
                <p>
                    "yoyo" quant √† lui permet d'indiquer qu'√† chaque r√©p√©tition de l'animation son sens soit invers√©.<br/>
                    Ainsi si on anime √† l'infini une box allant du gauche vers la droite sans pr√©ciser la propri√©t√© "yoyo" alors
                    elle fera infiniement le trajet de la gauche vers la droite.<br/>
                    Alors que si on indique la valeur "true" √† "yoyo" alors la box ira du gauche vers la droite, puis de la droite
                    vers la gauche etc.
                </p>
                <code>
                    const tween_8_1 = gsap.to(".animation--8 .square", {<br />
                    &nbsp;&nbsp;&nbsp;&nbsp;x: 600,<br />
                    &nbsp;&nbsp;&nbsp;&nbsp;repeat: -1,<br />
                    &nbsp;&nbsp;&nbsp;&nbsp;duration: 2,<br />
                    &nbsp;&nbsp;&nbsp;&nbsp;paused: true,<br />
                    });<br />
                    const tween_8_2 = gsap.to(".animation--8 .square", {<br />
                    &nbsp;&nbsp;&nbsp;&nbsp;x: 600,<br />
                    &nbsp;&nbsp;&nbsp;&nbsp;repeat: -1,<br />
                    &nbsp;&nbsp;&nbsp;&nbsp;yoyo: true,<br />
                    &nbsp;&nbsp;&nbsp;&nbsp;duration: 2,<br />
                    &nbsp;&nbsp;&nbsp;&nbsp;paused: true<br />
                    });<br />
                    document.getElementById('anim_8_1_button').addEventListener('click', () => {<br />
                    &nbsp;&nbsp;&nbsp;&nbsp;tween_8_2.pause();<br />
                    &nbsp;&nbsp;&nbsp;&nbsp;gsap.set(".animation--8 .square", { x: 0 });<br />
                    &nbsp;&nbsp;&nbsp;&nbsp;tween_8_1.restart();<br />
                    });<br />
                    document.getElementById('anim_8_2_button').addEventListener('click', () => {<br />
                    &nbsp;&nbsp;&nbsp;&nbsp;tween_8_1.pause();<br />
                    &nbsp;&nbsp;&nbsp;&nbsp;gsap.set(".animation--8 .square", { x: 0 });<br />
                    &nbsp;&nbsp;&nbsp;&nbsp;tween_8_2.restart();<br />
                    });<br />
                </code>
                <div class="preview animation-container animation--8">
                    <div class="square-ghost square-ghost--a">A</div>
                    <div class="square">Square</div>
                    <div class="square-ghost square-ghost--b">B</div>
                    <button id="anim_8_1_button" class="button">Jouer l'animation en repeat</button>
                    <button id="anim_8_2_button" class="button">Jouer l'animation en repeat avec yoyo</button>
                </div>
            </section>
            <hr>
            <section id="section_5">
                <h2>Easing</h2>
                <p>
                    La propri√©t√© "ease" est probablement la propri√©t√© la plus importante
                    pour donner de la personnalit√© √† son animation.<br />
                    Elle permet en effet de g√©rer la m√©thode de d√©roulement de notre animation.<br/><br/>

                    Derri√®re cette propri√©t√© se cache simplement une courbe math√©matique avec laquelle on
                    peut int√©ragir.
                </p>
                <p>
                    Chaque m√©thode d'animation poss√®de 3 types : <strong>in</strong>, <strong>out</strong> et
                    <strong>inOut</strong>.
                </p>
                <ul>
                    <li><strong>in</strong> : commence doucement</li>
                    <li><strong>out</strong> : termine doucement</li>
                    <li><strong>inOut</strong> : commence et termine doucement</li>
                </ul>
                <p>
                    Il existe plusieurs m√©thodes que nous allons voir ci-dessous, mais on peut toutes les retrouver
                    dans la <a href="https://gsap.com/resources/getting-started/Easing">documentation easing</a> de
                    GSAP.
                </p>
                <h3>power de 1 √† 4</h3>
                <p>
                    Correspond simplement √† une acc√©l√©ration constante plus ou moins rapide
                    avec un ralentissement en fonction du type choisi (in/out/inOut).
                </p>
                <div class="preview animation-container animation--9">
                    <div class="square-ghost square-ghost--a">A</div>
                    <div class="square">Square</div>
                    <div class="square-ghost square-ghost--b">B</div>
                    <button id="anim_9_1_button" class="button">power1.inOut</button>
                    <button id="anim_9_2_button" class="button">power2.inOut</button>
                    <button id="anim_9_3_button" class="button">power3.inOut</button>
                    <button id="anim_9_4_button" class="button">power4.inOut</button>
                </div>
                <h3>back</h3>
                <p>
                    La courbe donne un un effet de retour en arri√®re, c'est √† dire que l'effet
                    va plus loin qu'il est cens√© all√© avant d'atteindre son objectif.
                </p>
                <div class="preview animation-container animation--10">
                    <div class="square-ghost square-ghost--a">A</div>
                    <div class="square">Square</div>
                    <div class="square-ghost square-ghost--b">B</div>
                    <button id="anim_10_button" class="button">back.inOut</button>
                </div>
                <h3>bounce</h3>
                <p>
                    Effet assez simple √† comrendre il s'agit d'un effet qui inclus un effet de
                    rebond.
                </p>
                <div class="preview animation-container animation--11">
                    <div class="square-ghost square-ghost--a">A</div>
                    <div class="square">Square</div>
                    <div class="square-ghost square-ghost--b">B</div>
                    <button id="anim_11_button" class="button">bounce.out</button>
                </div>
                <h3>circ</h3>
                <p>
                    Effet incluant une courbe circulaire.
                </p>
                <div class="preview animation-container animation--12">
                    <div class="square-ghost square-ghost--a">A</div>
                    <div class="square">Square</div>
                    <div class="square-ghost square-ghost--b">B</div>
                    <button id="anim_12_button" class="button">circ.out</button>
                </div>
                <h3>elastic</h3>
                <p>
                    Effet incluant une courbe elastic, diff√©rent du rebond car cette fois-ci
                    la courbe d√©passe la destination avant de revenir.
                </p>
                <div class="preview animation-container animation--13">
                    <div class="square-ghost square-ghost--a">A</div>
                    <div class="square">Square</div>
                    <div class="square-ghost square-ghost--b">B</div>
                    <button id="anim_13_button" class="button">elastic.out</button>
                </div>
                <h3>expo</h3>
                <p>
                    Effet repr√©sentant simplement une courbe exponentielle.
                </p>
                <div class="preview animation-container animation--14">
                    <div class="square-ghost square-ghost--a">A</div>
                    <div class="square">Square</div>
                    <div class="square-ghost square-ghost--b">B</div>
                    <button id="anim_14_button" class="button">expo.out</button>
                </div>
                <h3>sine</h3>
                <p>
                    Effet repr√©sentant simplement une courbe sinusoidale.
                </p>
                <div class="preview animation-container animation--15">
                    <div class="square-ghost square-ghost--a">A</div>
                    <div class="square">Square</div>
                    <div class="square-ghost square-ghost--b">B</div>
                    <button id="anim_15_button" class="button">sine.out</button>
                </div>
                <h3>sine</h3>
                <p>
                    Effet repr√©sentant simplement une courbe sinusoidale.
                </p>
                <div class="preview animation-container animation--16">
                    <div class="square-ghost square-ghost--a">A</div>
                    <div class="square">Square</div>
                    <div class="square-ghost square-ghost--b">B</div>
                    <button id="anim_16_5_button" class="button">steps(5)</button>
                    <button id="anim_16_10_button" class="button">steps(10)</button>
                    <button id="anim_16_15_button" class="button">steps(15)</button>
                </div>
                <h3>Les plus complexes</h3>
                <p>
                    Il en existe d'autres qui n√©cessite des param√®trages plus complexes et
                    qui permettent d'obtenir des rendus vraiment diff√©rents.
                </p>
                <ul>
                    <li><strong>rough</strong></li>
                    <li><strong>slow</strong></li>
                    <li><strong>expoScale</strong></li>
                    <li><strong>CustomEase</strong></li>
                    <li><strong>CustomBounce</strong></li>
                    <li><strong>CustomWiggle</strong></li>
                </ul>
            </section>
        </main>
        <script type="module" src="../scripts/anim_1.js"></script>
    </body>
</html>
