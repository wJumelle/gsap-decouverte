<!DOCTYPE html>
<html lang="fr">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Getting started</title>
    </head>
    <body class="page page--category-1">
        <header>
            <nav>
                <a href="../../index.html">Retour √† l'accueil</a>
            </nav>
            <h1>Getting started</h1>
        </header>
        <main>
            <p>Il est l'heure de commencer √† apprendre ! ü§ì</p>
            <section>
                <h2>D√©composition d'un appel GSAP</h2>
                <code>
                    gsap.to(".square", { x: 600 })
                </code>
                <p>
                    Ici on demande √† <strong>gsap</strong> de faire appel √† la <strong>m√©thode</strong> to(),
                    de cibler la <strong>target</strong> ".square", donc notre √©l√©ment HTML poss√©dant la classe "square",
                    et d'y appliquer les transformations fournies en <strong>variables</strong>, ici {x: 600}.
                </p>
                <span>
                    Il existe 4 m√©thodes diff√©rentes :
                </span>
                <ul class="list">
                    <li>gsap.to()</li>
                    <li>gsap.from()</li>
                    <li>gsap.fromTo()</li>
                    <li>gsap.set()</li>
                </ul>
            </section>
            <hr>
            <section>
                <h2>D√©couverte des diff√©rentes m√©thodes</h2>
                <h3>1 - gsap.to()</h3>
                <p>
                    Elle correspond √† notre premi√®re m√©thode. C'est basiquement la plus utilis√©e car elle
                    repr√©sente la fonctionnalit√© la plus attendue : on part d'un √©tat A (l'origine) et
                    on anime jusqu'√† un √©tat B.
                    L'origine correspond au positionnement initial de l'√©l√©ment HTML tel qu'il est positionn√©
                    dans le DOM √† l'aide du CSS.
                </p>
                <code>
                    const tween_1 = gsap.to(".animation--1 .square", { x: 600 });<br/>
                    document.getElementById('anim_1_button').addEventListener('click', () => {<br/>
                    &nbsp;&nbsp;&nbsp;&nbsp;tween_1.restart();<br/>
                    });
                </code>
                <div class="preview animation-container animation--1">
                    <div class="square-ghost square-ghost--a">A</div>
                    <div class="square">Square</div>
                    <div class="square-ghost square-ghost--b">B</div>
                    <button id="anim_1_button" class="button">Jouer l'animation</button>
                </div>
                <p>
                    On a ainsi cr√©√© un <strong>tween</strong>, c'est √† dire une animation.
                    C'est souvent ce nom que va porter la constante lorsque l'on va nommer notre √©l√©ment pour
                    g√©rer son d√©clenchement.<br/>
                </p>
                <h3>2 - gsap.from()</h3>
                <p>
                    C'est l'inverse de la m√©thode to(), on a l'√©tat initial de notre carr√© qui
                    est toujours le m√™me, soit la position par d√©faut d'un √©l√©ment positionn√© relativement,
                    en haut √† gauche.<br />
                    Ici, on indique donc une animation qui simule un nouvel √©tat d'origine (B) pour aller
                    vers notre √©tat initial (A).
                </p>
                <code>
                    const tween_2 = gsap.from(".animation--2 .square", { x: 600 });<br/>
                    document.getElementById('anim_2_button').addEventListener('click', () => {<br/>
                    &nbsp;&nbsp;&nbsp;&nbsp;tween_2.restart();<br/>
                    });
                </code>
                <div class="preview animation-container animation--2">
                    <div class="square-ghost square-ghost--a">A</div>
                    <div class="square">Square</div>
                    <div class="square-ghost square-ghost--b">B</div>
                    <button id="anim_2_button" class="button">Jouer l'animation</button>
                </div>
                <h3>3 - gsap.fromTo()</h3>
                <p>
                    Cette m√©thode est la fusion des deux premi√®res, on d√©finit √† la fois
                    la valeur de l'√©tat de d√©but/origine et la valeur de l'√©tat de fin.<br/>
                    Elle permet de g√©rer avec certitude les diff√©rents √©tats d'une animation.
                </p>
                <code>
                    const tween_3 = gsap.fromTo(".animation--3 .square", { x: 0 }, { x: 600 });<br/>
                    document.getElementById('anim_3_button').addEventListener('click', () => {<br/>
                    &nbsp;&nbsp;&nbsp;&nbsp;tween_3.restart();<br/>
                    });
                </code>
                <div class="preview animation-container animation--3">
                    <div class="square-ghost square-ghost--a">A</div>
                    <div class="square">Square</div>
                    <div class="square-ghost square-ghost--b">B</div>
                    <button id="anim_3_button" class="button">Jouer l'animation</button>
                </div>
                <h3>4 - gsap.set()</h3>
                <p>
                    Et enfin, la m√©thode set est tout simplement une m√©thode qui va sauter de l'√©tat
                    d'origine vers l'√©tat final de l'animation sans animer la chose.
                </p>
                <code>
                    const tween_4 = gsap.set(".animation--4 .square", { x: 600, paused: true });<br/>
                    document.getElementById('anim_4_button_play').addEventListener('click', () => {<br/>
                    &nbsp;&nbsp;&nbsp;&nbsp;tween_4.restart();<br/>
                    });<br/>
                    document.getElementById('anim_4_button_reset').addEventListener('click', () => {<br/>
                    &nbsp;&nbsp;&nbsp;&nbsp;tween_4.reverse();<br/>
                    });
                </code>
                <div class="preview animation-container animation--4">
                    <div class="square-ghost square-ghost--a">A</div>
                    <div class="square">Square</div>
                    <div class="square-ghost square-ghost--b">B</div>
                    <button id="anim_4_button_play" class="button">Jouer la non animation</button>
                    <button id="anim_4_button_reset" class="button">R√©initialiser la non animation</button>
                </div>
            </section>
            <hr>
            <section>
                <h2>Les targets</h2>
                <p>
                    Ce que GSAP appelle les <strong>targets</strong> ce sont tout simplement
                    les cibles de notre animation.<br />
                    Ces cibles peuvent √™tre de diff√©rentes natures mais concr√®tement derri√®re ce premier
                    param√®tre de notre m√©thode se cache un simple appel √† <strong>document.querySelectorAll()</strong>.
                </p>
                <span>Voici les natures diff√©rentes que peuvent prendre les targets</span>
                <ul>
                    <li>un s√©lecteur CSS simple ou complexe</li>
                    <li>une variable</li>
                    <li>un tableau d'instance</li>
                </ul>
                <code>
                    // une classe ou un ID<br />
                    gsap.to(".box", { x: 200 });<br />
                    gsap.to("#myBox", { x: 200 });<br /><br />

                    // un s√©lecteur CSS complexe<br />
                    gsap.to("section > .box", { x: 200 });<br /><br />

                    // une variable<br />
                    let box = document.querySelector(".box");<br />
                    gsap.to(box, { x: 200 })<br /><br />

                    // un tableau d'√©l√©ments<br />
                    let square = document.querySelector(".square");<br />
                    let circle = document.querySelector(".circle");<br />
                    gsap.to([square, circle], { x: 200 })
                </code>
            </section>
            <hr>
            <section>
                <h2>Les variables</h2>
                <h3>Les propri√©t√©s CSS</h3>
                <p>
                    L'objet de variable contient toutes les informations autour de notre animation.<br/>
                    Il peut s'agir de <strong>simple propri√©t√© CSS</strong> ou bien des
                    <strong>propri√©t√©s sp√©cifiques</strong> qui influencent sur le comportement de
                    l'animation (ex: <strong>duration</strong>, <strong>onComplete</strong>, <strong>repeat</strong>).
                </p>
                <p>
                    Il n'existe pas de liste exacte des propri√©t√©s qui peuvent anim√©es puisque toutes
                    les propri√©t√©es CSS en soit peuvent l'√™tre.<br />
                    GSAP de son cot√© n'attend qu'une seule chose, que la propri√©t√© soit √©crite en camelCase.
                </p>
                <p class="highlighted">
                    üí° Tips, et un peu üö® attention aussi..<br/>
                    Cependant, il est conseill√© de se tenir √† quelques propri√©t√©s CSS optimis√©es pour l'animation.<br />
                    Et dans ce cas de figure, il en existe surtout deux : <strong>transform</strong> et <strong>opacity</strong>.<br />
                    En effet, d'autres propri√©t√©s CSS s'av√®rent √™tre tr√®s gourmandes au niveau du CPU et cela
                    pourrait nuire √† l'exp√©rience de l'utilisateur ! (ex: <strong>filter</strong> et <strong>boxShadow</strong>)
                </p>
                <p>
                    C'est pour favoriser l'usage de ces deux propri√©t√©s d'ailleurs que GSAP a mis en
                    place des raccourcis pour les animer.<br />
                    Ainsi <strong>x</strong> que l'on animait jusque l√† est un raccourci pour <strong>transform: translateX(x)</strong>.
                </p>
                <code>
                    // Pour ce qui est de transform et opacity
                    x: 200, // transfrom: translateX(200px)<br />
                    y: 200, // transfrom: translateY(200px)<br />
                    xPercent: 50, // transfrom: translateX(50%)<br />
                    yPercent: 50, // transfrom: translateY(50%)<br />
                    scale: 2, // transfrom: scale(2)<br />
                    scaleX: 2, // transfrom: scaleX(2)<br />
                    scaleY: 2, // transfrom: scaleY(2)<br />
                    rotation: 90, // transfrom: rotation(90deg)<br />
                    rotation: "1.25rad", // r√©alise la transformation en radian, pas d'alternative CSS<br />
                    transformOrigin: "center 40%", // transform-origin: center 40%<br />
                    opacity: 0,<br />
                    autoAlpha: 0, // ajuste les props opacity et visiblity<br />
                    duration: 1, // animation-duration: 1s<br />
                    repeat: -1, // animation-iteration-count: infinite<br />
                    repeat: 2, // animation-iteration-count: 2<br />
                    delay: 2, // animation-delay: 2s<br />
                    yoyo: true, // animation-direction: alternate<br /><br />

                    // pour les autres propri√©t√©s en camelCase<br />
                    backgroundColor: 'red',
                </code>
                <h3>Les unit√©s</h3>
                <p>
                    Par d√©faut GSAP utilise les pixels (px) et les degr√©s (deg) pour les propri√©t√©s autour
                    de <strong>transform</strong>, mais il est tout √† fait possible d'en utiliser d'autres,
                    ou bien de lui transmettre un calcul via une fonction.
                </p>
                <code>
                    x: 200, // use default of px<br />
                    x: "+=200" // relative values<br />
                    x: '40vw', // or pass in a string with a different unit for GSAP to parse<br />
                    x: () => window.innerWidth / 2, // you can even use functional values to do a calculation!<br /><br />

                    rotation: 360 // use default of degrees<br />
                    rotation: "1.25rad" // use radians
                </code>
                <h3>Les attributs SVG</h3>
                <p>
                    Tout comme les propri√©t√©s CSS, les attributs de nos SVG sont animables ! ‚ú®<br/>
                    Cela veut donc dire qu'avec GSAP nous pouvons animer des attributs comme <strong>fill</strong>,
                    <strong>width</strong>, <strong>height</strong>, <strong>stroke</strong>, <strong>cx/rx</strong>,
                    <strong>opacity</strong> ou bien encore l'attribut <strong>viewBox</strong> directement !
                </p>
                <p>
                    Ci-dessous un code test, nous pouvons voir que nous r√©alisons les transformations
                    <strong>x: 100</strong> et <strong>xPercent: -100</strong>, pourquoi ?<br />
                    Tout comme en CSS, nous r√©alisons souvent ce petit trick, nous d√©pla√ßons l'objet
                    √† sa valeur maximal puis on soustrait la taille de l'objet afin qu'il se positionne
                    dans la limite de l'encadrement, sinon il sortirait du viewbox de notre svg !
                </p>
                <code>
                    // Animation 5 - SVG<br />
                    const tween_5 = gsap.to('.animation--5 .svgBox', {<br />
                    &nbsp;&nbsp;&nbsp;&nbsp;duration: 2,<br />
                    &nbsp;&nbsp;&nbsp;&nbsp;x: 100,<br />
                    &nbsp;&nbsp;&nbsp;&nbsp;xPercent: -100,<br />
                    &nbsp;&nbsp;&nbsp;&nbsp;paused: true,<br />
                    &nbsp;&nbsp;&nbsp;&nbsp;attr: {<br />
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fill: "#5235F4",<br />
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rx: 50<br />
                    &nbsp;&nbsp;&nbsp;&nbsp;}<br />
                    });<br />
                    document.getElementById('anim_5_button').addEventListener('click', () => {<br />
                    &nbsp;&nbsp;&nbsp;&nbsp;tween_5.restart();<br />
                    });
                </code>
                <div class="preview animation-container animation--5">
                    <svg id="svg" viewBox="0 0 100 100">
                        <rect fill="#F43578" class="svgBox" x="0" y="35" width="30" height="30" rx="2" />
                    </svg>
                    <button id="anim_5_button" class="button">Jouer l'animation</button>
                </div>
                <p class="highlighted">
                    üö® Attention<br />
                    Lors de mes tests j'ai voulu g√©rer l'attribut <strong>fill</strong> en CSS, pour
                    pouvoir y mettre mes variables, ce qui casse le fonctionnement de GSAP.<br />
                    En effet, comme j'avais supprim√© l'attribut de mon code HTML, GSAP n'√©tait plus en
                    mesure d' en animer sa valeur.
                </p>
            </section>
        </main>
        <script type="module" src="../scripts/anim_1.js"></script>
    </body>
</html>
